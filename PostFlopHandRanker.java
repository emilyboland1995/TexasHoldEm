/**
 * HandRanker defines a single method called getHandRank which produces a numeric representation
 * of the highest possible hand, given a Card[] representing the current board cards combined 
 * with one player's hole cards. This numeric representation of the most powerful hand can be
 * used to quickly compare the strength of two respective hands.
 * 
 * Requirement Sets: 1.7.0
 */

import java.util.*;

public class PostFlopHandRanker {
	//private static String[] suits = {"Spades", "Clubs", "Hearts", "Diamonds"};
	private static String[] ranks = {
			"Ace", "2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King"
	  };
	
	// Relative hand rankings by type
	private static final long STRAIGHT_FLUSH = 9;
	private static final long FOUR_OF_A_KIND = 8;
	private static final long FULL_HOUSE = 7;
	private static final long FLUSH = 6;
	private static final long STRAIGHT = 5;
	private static final long THREE_OF_A_KIND = 4;
	private static final long TWO_PAIRS = 3;
	private static final long PAIR = 2;
	private static final long HIGH_CARD = 1;
	private static final long majorFactor = Math.multiplyExact((long) 10000, 1000000);
	
	/**
	 * Takes the absolute rank of a hand as generated by the getAbsoluteHandStrength
	 * method and returns a String representation
	 * @param absoluteRank		The absolute rank of a hand as
	 * 							generated by the getAbsoluteHandStrength
	 * 							method
	 * @return					A String of the hand represented by the
	 * 							absoluteRank passed
	 * 
	 * Requirement: 1.7.3
	 */
	public static String getHandStringFromRank(long absoluteRank) {
		int handType = (int) (absoluteRank / majorFactor);
		int typeRank = (int) (absoluteRank % (majorFactor * handType)) 
				/ 100000000;
		String hand = "";
		switch(handType) {
			case 9: // Straight flush
				hand += "Straight Flush";
				if (typeRank == 14) { // Check for royal flush
					hand = "Royal Flush";
				} else {
					hand += ", " + ranks[(typeRank - 1) % 13] + " high";
				}
				break;
			case 8: // Four of a kind
				hand += "Four of a kind: ";
				if (typeRank == 14) { // Check for royal flush
					hand += "Aces";
				} else {
					hand += ranks[(typeRank - 1) % 13] + "s";
				}
				break;
			case 7: // Full house
				hand += "Full House, ";
				if (typeRank == 14) { // Ace high
					hand += "Aces ";
				} else {
					hand += ranks[(typeRank - 1) % 13] + "s ";
				}
				hand += "over ";
				int typeRankLow = (int) (absoluteRank % 100000000) 
						/ 1000000;
				if (typeRankLow == 14) { // Ace high
					hand += "Aces ";
				} else {
					hand += ranks[(typeRankLow - 1) % 13] + "s";
				}
				break;
			case 6: // Flush
				hand += "Flush,";
				long remainder = absoluteRank % majorFactor;
				long divisor = majorFactor / 100;
				for (int i = 0; i < 5; i++) {
					int rank = (int) (remainder / divisor);
					if (rank == 14) { // Ace
						hand += " Ace";
					} else {
						hand += " " + ranks[(rank - 1) % 13];
					}
					remainder -= rank * divisor;
					divisor /= 100;
				}
				break;
			case 5: // Straight
				hand += ranks[(typeRank - 1) % 13];
				hand += " high straight";
				break;
			case 4: // Three of a kind
				hand += "Three of a kind: ";
				hand += ranks[(typeRank - 1) % 13] + "s";
				break;
			case 3: // Two pairs
				hand += "Two pair: ";
				hand += ranks[(typeRank - 1) % 13] + "s and ";
				int lowPairRank = (int) (absoluteRank % 100000000)  / 1000000;
				hand += ranks[(lowPairRank - 1) % 13] + "s";
				break;
			case 2: // One pair
				hand += "One pair: ";
				hand += ranks[(typeRank - 1) % 13] + "s";
				break;
			case 1: // High card only
				hand += "High card: ";
				hand += ranks[(typeRank - 1) % 13];
				break;
			default: 
				return null; // Error
		}
		return hand;
	}
	
	/**
	 * Calculates and returns the strength of the strongest hand possible
	 * given the player's hole cards plus any board cards.
	 * @param holeCards		A Card[] containing one player's hole cards
	 * @param boardCards	A Card[] containing all visible board cards
	 * @return				A long containing a numeric representation of this
	 * 						hand which representing its relative strength.
	 * 
	 * Requirement: 1.7.1
	 */
	public static long getAbsoluteHandStrength(Card[] holeCards, Card[] boardCards) {
		return getAbsoluteHandStrength(createHand(holeCards, boardCards));
	}
	
	/**
	 * Calculates and returns the strength of the strongest hand possible
	 * given the player's hole cards plus any board cards.
	 * @param hand		An ArrayList<Card> containing one hand of cards
	 * @return			A long containing a numeric representation of this
	 * 					hand which representing its relative strength.
	 * 
	 * Requirement: 1.7.1
	 */
	public static long getAbsoluteHandStrength(ArrayList<Card> hand) {
		return getAbsoluteHandStrength(createHandFromArrayList(hand));
	}
	
	/**
	 * Combines one player's hole cards and all visible board cards to create
	 * a single Card[].
	 * @param holeCards		A Card[] containing one player's hole cards
	 * @param boardCards	A Card[] containing all visible board cards
	 * @return				A Card[] containing both the hole cards and the
	 * 						visible board cards
	 * 
	 * Requirement: 1.7.1
	 */
	private static Card[] createHand(Card[] holeCards, Card[] boardCards) {
		if (holeCards.length != 2 || boardCards.length < 3 || boardCards.length > 5) {
			throw new IllegalArgumentException("Invalid number of cards provided.");
		}
		Card[] hand = new Card[holeCards.length + boardCards.length];
		hand[0] = holeCards[0];
		hand[1] = holeCards[1];
		
		for (int i = 2; i < hand.length; i++) {
			hand[i] = boardCards[i - 2];
		}
		
		return hand;
	}
	/**
	 * Creates a Card[] containing from an ArrayList<Card>. Removes any
	 * null values.
	 * @param handList		An ArrayList<Card> containing a single hand of cards (5-7)
	 * @return				A Card array containing all Card objects contained
	 * 						in handList, minus any null pointers, only if
	 * 						the number of non-null Card objects in handList
	 * 						is between 5 and 7
	 */
	private static Card[] createHandFromArrayList(ArrayList<Card> handList) {
		int numCards = 0;
		for (Card c : handList) {
			if (c != null) {
				numCards++;
			}
		}
		if (numCards + 1 < 5) {
			throw new IllegalArgumentException("Invalid number of cards found in handList");
		}
		Card[] hand = new Card[numCards];
		int index = 0;
		for (Card c : handList) {
			if (c != null) {
				hand[index] = c;
				index++;
			}
		}
		return hand;
	}
	
	/**
	 * Calculates and returns the strength of the strongest hand possible
	 * given the player's hole cards plus any board cards.
	 * @param hand		One player's hole cards plus any board cards
	 * @return			A long containing a numeric representation of this
	 * 					hand which representing its relative strength.
	 * 
	 * Requirement: 1.7.1
	 */
	public static long getAbsoluteHandStrength(Card[] hand) {
		int[] suitCounts = new int[4];
		int[] rankCounts = new int[13];
		int containsStraight = -1;
		int containsFlush = -1;
		int threeOfAKind = -1;
		int auxThreeOfAKind = -1;
		int fourOfAKind = -1;
		int twoOfAKindHigh = -1;
		int twoOfAKindLow = -1;
		
		// Complete hand pre-processing
		sortByRank(hand); // Sort the hand by rank
		
		// Count suits and ranks and finds high card
		for (int i = 0; i < hand.length; i++) {
			suitCounts[hand[i].getSuitInt() - 1]++;
			rankCounts[hand[i].getRankInt() - 1]++;
		}
		
		// Check for multiples
		boolean threeFound = false;
		boolean twoFound = false;
		for (int i = rankCounts.length; i > 0; i--) {
			// Check for and track multiples
			int rankCount = rankCounts[i - 1];
			if (rankCount >= 4){
				fourOfAKind = i;
			} else if (rankCount == 3) {
				if (!threeFound || i == 1) {
					auxThreeOfAKind = threeOfAKind;
					threeOfAKind = i;
					threeFound = true;
				} else if (threeFound && auxThreeOfAKind < 0) {
					auxThreeOfAKind = i;
				}
			} else if (rankCount == 2) {
				if (!twoFound || i == 1) {
					twoOfAKindLow = twoOfAKindHigh;
					twoOfAKindHigh = i;
					twoFound = true;
				} else if (twoFound && twoOfAKindLow < 0) {
					twoOfAKindLow = i;
				}
			}
		}
		
		containsStraight = checkForStraight(rankCounts);
		containsFlush = checkForFlush(suitCounts);
		
		long handRank = -1;
		
		// Check for straight flush when one might exist
		if (containsFlush >= 0 && containsStraight >= 0) {
			handRank = getStraightFlushRank(hand, containsFlush);
			if (handRank > -1) {
				return handRank; // Straight flush found
			}
		}
		
		// Get rank for four of a kind if present
		if (fourOfAKind > 0) {
			return getFourOfAKindRank(fourOfAKind);
		}
		
		// Get rank for full house if it might be present
		if (threeOfAKind >= 0 && (auxThreeOfAKind >= 0 
				|| twoOfAKindHigh >= 0)) {
			return getFullHouseRank(rankCounts);
		}
		
		// Get rank for flush if present
		if (containsFlush >= 0) {
			return getFlushRank(containsFlush, hand);
		}
		
		// Get rank for straight if present
		if (containsStraight >= 0) {
			return getStraightRank(containsStraight);
		}
		
		// Get rank for three of a kind, if present
		if (threeOfAKind >= 0) {
			return getThreeOfAKindRank(threeOfAKind, hand);
		}
		
		// Get rank for two pairs, if present
		if (twoOfAKindHigh > -1 && twoOfAKindLow > -1) {
			return getTwoPairRank(twoOfAKindHigh, twoOfAKindLow, hand);
		}
		
		// Get rank for pair
		if (twoOfAKindHigh > -1) {
			return getPairRank(twoOfAKindHigh, hand);
		}
		
		// Get high card rank
		return getHighCardRank(hand);
	}
	/**
	 * Generates the ranking of a hand with nothing
	 * better than a high card
	 * @param hand		A Card[] containing one hand
	 * @return			The ranking of the and contained
	 * 					in hand
	 */
	public static long getHighCardRank(Card[] hand) {
		long handRank = 0;
		int cardsSelected = 0;
		int index = hand.length - 1;
		if (hand[0].getRankInt() == 1) {
			handRank += 14;
			cardsSelected++;
		}
		while (index >= 0 && cardsSelected < 5) {
			handRank *= 100;
			handRank += hand[index].getRankInt();
			cardsSelected++;
			index--;
		}
		return handRank + (HIGH_CARD * majorFactor);
	}
	
	/**
	 * Generates the ranking of a hand with two pair and
	 * nothing stronger
	 * @param twoOfAKindRank	An int (1-13) representing the
	 * 							rank of the pair
	 * @param hand				A Card[] containing the hand
	 * @return					A long containing the rank of the
	 * 							hand
	 */
	private static long getPairRank(int twoOfAKindRank, Card[] hand) {
		long handRank = PAIR * majorFactor;
		if (twoOfAKindRank == 1) {
			handRank += 1400000000;
		} else {
			handRank += twoOfAKindRank * 100000000;
		}
		int cardsSelected = 0;
		long highCardRankings = 0;
		int index = hand.length - 1;
		if (hand[0].getRankInt() == 1 && twoOfAKindRank != 1) {
			highCardRankings += 14;
			cardsSelected++;
		}
		while (index >= 0 && cardsSelected < 3) {
			if (hand[index].getRankInt() != twoOfAKindRank) {
				highCardRankings *= 100;
				highCardRankings += hand[index].getRankInt();
				cardsSelected++;
			}
			index--;
		}
		return handRank += highCardRankings;
	}
	/**
	 * Generates the ranking of a hand containing two pair
	 * and nothing stronger
	 * @param twoOfAKindHighRank	An int (1-13) representing the
	 * 								rank of the high pair
	 * @param twoOfAKindLowRank		An int (1-13) representing the 
	 * 								rank of a the low pair
	 * @param hand					A Card[] containing the hand
	 * @return						A long containing the rank of 
	 * 								the hand
	 */
	private static long getTwoPairRank(int twoOfAKindHighRank, 
			int twoOfAKindLowRank, Card[] hand) {
		long handRank = TWO_PAIRS * majorFactor;
		if (twoOfAKindHighRank == 1) {
			handRank += 1400000000;
		} else {
			handRank += twoOfAKindHighRank * 100000000;
		}
		if (twoOfAKindLowRank == 1) {
			handRank += 14000000;
		} else {
			handRank += twoOfAKindLowRank * 1000000;
		}
		if (hand[0].getRankInt() == 1 && twoOfAKindHighRank != 1) {
			handRank += 140000;
		} else {
			for (int i = hand.length - 1; i >= 0; i--) {
				int cardRank = hand[i].getRankInt();
				if (cardRank != twoOfAKindHighRank 
						&& cardRank != twoOfAKindLowRank) {
					if (cardRank == 1) {
						handRank += 140000;
					} else {
						handRank += cardRank * 10000;
					}
					break;
				}
			}
		}
		return handRank;
	}
	
	/**
	 * Generates the ranking for a hand containing three of a kind and
	 * no better
	 * @param threeOfAKind		The rank of the card occurring three times
	 * @return					The rank of the hand containing the
	 * 							three cards of the rank specified by 
	 * 							threeOfAKind
	 */
	private static long getThreeOfAKindRank(int threeOfAKind, Card[] hand) {
		long handRank = THREE_OF_A_KIND * majorFactor;
		if (threeOfAKind == 1) {
			handRank += 1400000000;
		} else {
			handRank += threeOfAKind * 100000000;
		}
		int factor = 10000;
		int cardsSelected = 0;
		if (hand[0].getRankInt() == 1 && threeOfAKind != 1) {
			handRank += 140000;
			cardsSelected++;
		} 
		int index = hand.length - 1;
		while (cardsSelected < 2 && index >= 0) {
			int cardRank = hand[index].getRankInt();
			if (cardRank != threeOfAKind) {
				if (cardRank == 1) {
					handRank += 14 * factor;
				} else {
					handRank += cardRank * factor;
				}
				factor /= 100;
				cardsSelected++;
			}
			index--;
		}
		return handRank; 
	}
	
	/**
	 * Generates the ranking for a hand containing the straight
	 * @param straightHighCardRank		The rank of the highest card
	 * 									in the straight
	 * @return							The rank of the hand containing
	 * 									the straight with the high card
	 * 									specified by straightHighCardRank
	 */
	private static long getStraightRank(int straightHighCardRank) {
		return (STRAIGHT * majorFactor) 
				+ straightHighCardRank * 100000000;
	}
	
	/**
	 * Finds and returns the rank of a hand containing a flush.
	 * @param flushSuit		The suit (1-4) of the flush contained
	 * 						in the hand
	 * @param hand			The Card[] containing a full hand
	 * @return				The hand rank, assuming a flush is
	 * 						present
	 */
	private static long getFlushRank(int flushSuit, Card[] hand) {
		long handRank = FLUSH * majorFactor;
		int cardsSelected = 0;
		long highCardRankings = 0;
		int index = 0;
		while (hand[index].getRankInt() == 1) { // Check for aces
			if (hand[index].getSuitInt() == flushSuit) {
				highCardRankings *= 100;
				highCardRankings += 14;
				cardsSelected++;
			}
			index++;
		}		
		index = hand.length - 1;
		while (index >= 0 && cardsSelected < 5) { // Handle normally ranked cards
			if (hand[index].getSuitInt() == flushSuit) {
				highCardRankings *= 100;
				highCardRankings += hand[index].getRankInt();
				cardsSelected++;
			}
			index--;
		}
		return handRank += highCardRankings;
	}
	

	
	/**
	 * Checks if a hand contains a full house.
	 * @param rankCounts		An int[] containing the count
	 * 							of each type of rank present in
	 * 							a hand.
	 * @return					The rank of the hand if it contains
	 * 							a full house. -1 if it does not.
	 */
	private static long getFullHouseRank(int[] rankCounts) {
		int threeIndex = -1;
		int twoIndex = -1;
		if (rankCounts[0] >= 3) {
			threeIndex = 0;
		} else {
			for (int i = rankCounts.length - 1; i >= 0; i--) {
				if (rankCounts[i] >= 3) {
					threeIndex = i;
					break;
				}
			}
		}
		if (threeIndex != 0 && rankCounts[0] >= 2) {
			twoIndex = 0;
		} else {
			for (int i = rankCounts.length - 1; i >= 0; i--) {
				if (rankCounts[i] >= 2 && i != threeIndex) {
					twoIndex = i;
					break;
				}
			}
		}
		if (threeIndex >= 0 && twoIndex >= 0) {
			long handRank = FULL_HOUSE * majorFactor;
			if (threeIndex + 1 == 1) { // Ace
				handRank += 1400000000;
			} else {
				handRank += (threeIndex + 1) * 100000000;
			}
			if (twoIndex + 1 == 1) { // Ace
				handRank += 14000000;
			} else {
				handRank += (twoIndex + 1) * 1000000;
			}
			return handRank; // Full house found
		}
		return -1; // Full house not found
	}
	
	/**
	 * Checks a hand for a flush 
	 * @param suitCounts		An int[] containing the number of
	 * 							cards of each suit in the hand.
	 * @return					The index of the suit that occurs
	 * 							greater than 5 times, if present.
	 * 							Returns -1 if no suit occurs more
	 * 							than 5 times.
	 */
	private static int checkForFlush(int[] suitCounts) {
		// Check for flush. If present, mark suit
		for (int i = 0; i < suitCounts.length; i++) {
			if (suitCounts[i] >= 5) {
				return i + 1;
			}
		}
		return -1;
	}
	/**
	 * 
	 * @param fourOfAKindRank	The rank (1-13) of the card
	 * 							occurring four times.
	 * @return					A long containing the rank
	 * 							of the hand.
	 */
	private static long getFourOfAKindRank(int fourOfAKindRank) {
		long handRank = FOUR_OF_A_KIND * majorFactor;
		if (fourOfAKindRank == 1) {
			handRank += 1400000000;
		} else {
			handRank += fourOfAKindRank * 100000000;
		}
		return handRank; // Four of a kind found
	}
	
	/**
	 * Checks for the presence of a straight flush in the
	 * hand provided.
	 * @param hand		 	A Card[] containing all the cards in
	 * 					 	the hand being examined
	 * @param flushSuit	 	An int (1-4) indicating the suit of the
	 * 					 	flush contained in hand
	 * @return			 	A long containing the value of the straight
	 * 					 	flush contained in the hand, if it contains
	 * 					 	one. Returns -1 otherwise
	 */
	private static long getStraightFlushRank(Card[] hand, int flushSuit) {
		// Get flush cards
		int[] suitedRankCounts = new int[13];
		for (int i = 0; i < hand.length; i++) {
			if (hand[i].getSuitInt() == flushSuit) {
				suitedRankCounts[hand[i].getRankInt() - 1]++;
			}
		}
		int hasStraight = checkForStraight(suitedRankCounts);
		if (hasStraight >= 0) { 
			long handRank = STRAIGHT_FLUSH * majorFactor; // Straight flush present
			handRank += hasStraight * 100000000; // Other straight flush
			return handRank;
		}
		return -1;
	}

	/**
	 * Checks the hand for a straight.
	 * @param rankCounts	An int[] containing the number of 
	 * 						cards of each rank.
	 * @return				The starting index of the straight
	 * 						if the hand contains one, -1 if it
	 * 						doesn't.
	 */
	private static int checkForStraight(int[] rankCounts) {
		// Check for Straight. Implicitly finds the straight of 
		// the highest value
		for (int i = rankCounts.length - 4; i >= 0; i--) {
			boolean straightFound = true;
			if (i == rankCounts.length - 4) {
				for (int j = i; j < i + 4; j++) {
					// If the straight is broken, break
					if (rankCounts[j] < 1) {
						straightFound = false;
						break;
					}
				}
				// Check for Ace high straight
				if (rankCounts[0] < 1) {
					straightFound = false;
				}
			} else {
				for (int j = i; j < i + 5 && j < rankCounts.length; j++) {
					// If the straight is broken, break
					if (rankCounts[j] < 1) {
						straightFound = false;
						break;
					}
				}
			}
			// If a straight is found, keep track of its location
			if (straightFound) {
				if (i == rankCounts.length - 4) { // Ace-high straight
					return 14;
				} else {
					return i + 5;
				}
			}
		}
		return -1; // Straight not found
	}
	
	/**
	 * Sorts a given hand by the rank of the cards
	 * @param hand		The hole cards plus any board cards
	 */
	public static void sortByRank(Card[] hand) {
		Arrays.sort(hand, new CompareByRank());
	}
	
	/**
	 * 
	 * A basic Comparator that compares cards by rank.
	 *
	 */
	private static class CompareByRank implements Comparator<Card> {

		@Override
		public int compare(Card o1, Card o2) {
			if (o1.getRankInt() > o2.getRankInt()) {
				return 1;
			} else if (o1.getRankInt() == o2.getRankInt()) {
				return 0;
			} else {
				return -1;
			}
		}
	}
}
